# 1.6 Configuration & Security

**Deliverable**: Configuration management, security controls, and operational monitoring
**Status**: ðŸš§ Partially Implemented - TOML configuration and basic security controls exist; Docker security and advanced monitoring are planned

## Configuration Management

### Hierarchical Configuration System

The system implements a sophisticated configuration hierarchy supporting environment-specific overrides:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentConfiguration {
    pub system: SystemConfig,
    pub session: SessionConfig,
    pub claude: ClaudeConfig,
    pub docker: DockerConfig,
    pub security: SecurityConfig,
    pub monitoring: MonitoringConfig,
    pub logging: LoggingConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemConfig {
    pub max_concurrent_sessions: u32,
    pub session_timeout_hours: u32,
    pub checkpoint_interval_minutes: u32,
    pub cleanup_retention_days: u32,
    pub temp_directory: PathBuf,
    pub data_directory: PathBuf,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionConfig {
    pub max_duration_hours: u32,
    pub max_tasks_per_session: u32,
    pub task_timeout_minutes: u32,
    pub auto_checkpoint: bool,
    pub recovery_enabled: bool,
    pub context_window_size: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClaudeConfig {
    pub api_key: SecretString,
    pub model: String,
    pub max_tokens: u32,
    pub temperature: f64,
    pub rate_limits: RateLimitConfig,
    pub retry_config: RetryConfig,
    pub usage_limits: UsageLimits,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DockerConfig {
    pub image_registry: String,
    pub image_name: String,
    pub image_tag: String,
    pub default_resources: ResourceLimits,
    pub network_config: NetworkConfig,
    pub volume_config: VolumeConfig,
    pub security_config: ContainerSecurityConfig,
}
```

### Configuration Loading and Validation

The system supports multiple configuration sources with validation:

```rust
pub struct ConfigurationManager {
    config_hierarchy: ConfigurationHierarchy,
    validators: Vec<Box<dyn ConfigValidator>>,
    secret_manager: Arc<SecretManager>,
    environment_resolver: Arc<EnvironmentResolver>,
}

#[derive(Debug, Clone)]
pub struct ConfigurationHierarchy {
    pub sources: Vec<ConfigurationSource>,
    pub merge_strategy: MergeStrategy,
    pub validation_rules: Vec<ValidationRule>,
}

#[derive(Debug, Clone)]
pub enum ConfigurationSource {
    DefaultValues,
    ConfigFile { path: PathBuf, format: ConfigFormat },
    EnvironmentVariables { prefix: String },
    CommandLineArgs,
    SecretStore { store_type: SecretStoreType },
}

#[derive(Debug, Clone)]
pub enum ConfigFormat {
    Toml,
    Yaml,
    Json,
    Env,
}

impl ConfigurationManager {
    pub async fn load_configuration(
        &self,
        config_path: Option<PathBuf>,
    ) -> Result<AgentConfiguration> {
        let mut config_builder = ConfigurationBuilder::new();

        // Load from hierarchy
        for source in &self.config_hierarchy.sources {
            match source {
                ConfigurationSource::DefaultValues => {
                    config_builder.merge(self.load_default_config().await?);
                }

                ConfigurationSource::ConfigFile { path, format } => {
                    let file_config = self.load_config_file(path, format).await?;
                    config_builder.merge(file_config);
                }

                ConfigurationSource::EnvironmentVariables { prefix } => {
                    let env_config = self.load_environment_config(prefix).await?;
                    config_builder.merge(env_config);
                }

                ConfigurationSource::CommandLineArgs => {
                    let args_config = self.load_args_config().await?;
                    config_builder.merge(args_config);
                }

                ConfigurationSource::SecretStore { store_type } => {
                    let secret_config = self.load_secret_config(store_type).await?;
                    config_builder.merge(secret_config);
                }
            }
        }

        let config = config_builder.build()?;

        // Validate configuration
        self.validate_configuration(&config).await?;

        // Resolve secrets
        let resolved_config = self.resolve_secrets(config).await?;

        Ok(resolved_config)
    }

    async fn validate_configuration(&self, config: &AgentConfiguration) -> Result<()> {
        for validator in &self.validators {
            validator.validate(config).await?;
        }

        // Built-in validations
        self.validate_system_constraints(config).await?;
        self.validate_security_requirements(config).await?;
        self.validate_resource_limits(config).await?;

        Ok(())
    }

    async fn validate_system_constraints(&self, config: &AgentConfiguration) -> Result<()> {
        // Validate resource constraints
        if config.docker.default_resources.memory_mb < 512 {
            return Err(ConfigurationError::InvalidValue {
                field: "docker.default_resources.memory_mb".to_string(),
                value: config.docker.default_resources.memory_mb.to_string(),
                constraint: "Must be at least 512MB".to_string(),
            });
        }

        if config.docker.default_resources.cpu_cores < 0.1 {
            return Err(ConfigurationError::InvalidValue {
                field: "docker.default_resources.cpu_cores".to_string(),
                value: config.docker.default_resources.cpu_cores.to_string(),
                constraint: "Must be at least 0.1 cores".to_string(),
            });
        }

        // Validate session constraints
        if config.session.max_duration_hours > 24 {
            return Err(ConfigurationError::InvalidValue {
                field: "session.max_duration_hours".to_string(),
                value: config.session.max_duration_hours.to_string(),
                constraint: "Must not exceed 24 hours".to_string(),
            });
        }

        Ok(())
    }
}
```

### Environment-Specific Configurations

The system supports sophisticated environment management:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentConfiguration {
    pub environment: Environment,
    pub overrides: HashMap<String, serde_json::Value>,
    pub feature_flags: HashMap<String, bool>,
    pub scaling_config: ScalingConfiguration,
    pub monitoring_config: EnvironmentMonitoringConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Environment {
    Development,
    Testing,
    Staging,
    Production,
    Custom(String),
}

impl Environment {
    pub fn default_config(&self) -> AgentConfiguration {
        match self {
            Environment::Development => {
                AgentConfiguration {
                    system: SystemConfig {
                        max_concurrent_sessions: 2,
                        session_timeout_hours: 2,
                        checkpoint_interval_minutes: 5,
                        cleanup_retention_days: 1,
                        temp_directory: PathBuf::from("/tmp/claude-agent-dev"),
                        data_directory: PathBuf::from("./data/dev"),
                    },
                    docker: DockerConfig {
                        default_resources: ResourceLimits {
                            memory_mb: 2048,
                            cpu_cores: 1.0,
                            disk_mb: 5000,
                            ulimits: HashMap::new(),
                            cgroup_limits: HashMap::new(),
                        },
                        // ... other dev-specific settings
                        ..Default::default()
                    },
                    logging: LoggingConfig {
                        level: LogLevel::Debug,
                        structured: true,
                        include_claude_traces: true,
                        console_output: true,
                        file_output: false,
                        ..Default::default()
                    },
                    // ... other dev configurations
                    ..Default::default()
                }
            }

            Environment::Production => {
                AgentConfiguration {
                    system: SystemConfig {
                        max_concurrent_sessions: 10,
                        session_timeout_hours: 8,
                        checkpoint_interval_minutes: 30,
                        cleanup_retention_days: 7,
                        temp_directory: PathBuf::from("/var/tmp/claude-agent"),
                        data_directory: PathBuf::from("/var/lib/claude-agent"),
                    },
                    docker: DockerConfig {
                        default_resources: ResourceLimits {
                            memory_mb: 8192,
                            cpu_cores: 4.0,
                            disk_mb: 20000,
                            ulimits: HashMap::from([
                                ("nofile".to_string(), 4096),
                                ("nproc".to_string(), 2048),
                            ]),
                            cgroup_limits: HashMap::new(),
                        },
                        security_config: ContainerSecurityConfig {
                            read_only_root_filesystem: true,
                            no_new_privileges: true,
                            drop_all_capabilities: true,
                            allowed_capabilities: vec!["NET_BIND_SERVICE".to_string()],
                            seccomp_profile: Some("runtime/default".to_string()),
                            apparmor_profile: Some("docker-default".to_string()),
                        },
                        ..Default::default()
                    },
                    logging: LoggingConfig {
                        level: LogLevel::Info,
                        structured: true,
                        include_claude_traces: false,
                        console_output: false,
                        file_output: true,
                        log_rotation: Some(LogRotationConfig {
                            max_size_mb: 100,
                            max_files: 10,
                            compression: true,
                        }),
                        ..Default::default()
                    },
                    // ... other production configurations
                    ..Default::default()
                }
            }

            // ... other environments
            _ => AgentConfiguration::default(),
        }
    }
}
```

## Security Architecture

### Multi-Layer Security Model

The system implements comprehensive security controls across all layers:

```rust
#[derive(Debug, Clone)]
pub struct SecurityConfig {
    pub authentication: AuthenticationConfig,
    pub authorization: AuthorizationConfig,
    pub encryption: EncryptionConfig,
    pub audit: AuditConfig,
    pub network_security: NetworkSecurityConfig,
    pub container_security: ContainerSecurityConfig,
    pub data_protection: DataProtectionConfig,
}

#[derive(Debug, Clone)]
pub struct AuthenticationConfig {
    pub method: AuthenticationMethod,
    pub token_lifetime: Duration,
    pub refresh_token_enabled: bool,
    pub multi_factor_required: bool,
    pub password_policy: PasswordPolicy,
}

#[derive(Debug, Clone)]
pub enum AuthenticationMethod {
    ApiKey { key_rotation_days: u32 },
    OAuth2 { provider: String, scopes: Vec<String> },
    JWT { signing_key: SecretString, algorithm: JwtAlgorithm },
    Certificate { ca_cert_path: PathBuf, client_cert_required: bool },
}

#[derive(Debug, Clone)]
pub struct AuthorizationConfig {
    pub rbac_enabled: bool,
    pub default_permissions: Vec<Permission>,
    pub role_definitions: Vec<RoleDefinition>,
    pub resource_policies: Vec<ResourcePolicy>,
}
```

### Secret Management

The system provides secure secret handling with multiple backend support:

```rust
pub struct SecretManager {
    backends: Vec<Box<dyn SecretBackend>>,
    cache: Arc<Mutex<SecretCache>>,
    rotation_scheduler: Arc<RotationScheduler>,
    audit_logger: Arc<AuditLogger>,
}

pub trait SecretBackend: Send + Sync {
    async fn get_secret(&self, key: &str) -> Result<SecretValue>;
    async fn set_secret(&self, key: &str, value: SecretValue) -> Result<()>;
    async fn delete_secret(&self, key: &str) -> Result<()>;
    async fn list_secrets(&self) -> Result<Vec<String>>;
    async fn rotate_secret(&self, key: &str) -> Result<SecretValue>;
}

#[derive(Debug, Clone)]
pub enum SecretBackend {
    Environment,
    File { path: PathBuf, encryption_key: SecretString },
    HashiCorpVault { endpoint: String, token: SecretString },
    AWSSecretsManager { region: String, profile: Option<String> },
    AzureKeyVault { vault_url: String, client_id: String },
    KubernetesSecret { namespace: String, secret_name: String },
}

impl SecretManager {
    pub async fn get_secret(&self, key: &SecretKey) -> Result<SecretValue> {
        // Check cache first
        if let Some(cached_value) = self.check_cache(key).await? {
            return Ok(cached_value);
        }

        // Try backends in order
        for backend in &self.backends {
            match backend.get_secret(&key.key).await {
                Ok(value) => {
                    // Cache the value
                    self.cache_secret(key, &value).await?;

                    // Audit access
                    self.audit_logger.log_secret_access(key, SecretOperation::Read).await?;

                    return Ok(value);
                }
                Err(SecretError::NotFound) => continue,
                Err(e) => return Err(e.into()),
            }
        }

        Err(SecretError::NotFound.into())
    }

    pub async fn rotate_secrets(&self) -> Result<RotationReport> {
        let mut report = RotationReport::new();

        // Get list of secrets to rotate
        let rotation_candidates = self.get_rotation_candidates().await?;

        for secret_key in rotation_candidates {
            match self.rotate_single_secret(&secret_key).await {
                Ok(new_value) => {
                    report.successful_rotations.push(secret_key.clone());
                    self.audit_logger.log_secret_rotation(&secret_key, true).await?;
                }
                Err(e) => {
                    report.failed_rotations.push((secret_key.clone(), e));
                    self.audit_logger.log_secret_rotation(&secret_key, false).await?;
                }
            }
        }

        Ok(report)
    }
}
```

### Encryption and Data Protection

The system implements comprehensive data protection:

```rust
#[derive(Debug, Clone)]
pub struct EncryptionConfig {
    pub encryption_at_rest: EncryptionAtRestConfig,
    pub encryption_in_transit: EncryptionInTransitConfig,
    pub key_management: KeyManagementConfig,
    pub compliance_requirements: Vec<ComplianceStandard>,
}

#[derive(Debug, Clone)]
pub struct EncryptionAtRestConfig {
    pub enabled: bool,
    pub algorithm: EncryptionAlgorithm,
    pub key_derivation: KeyDerivationConfig,
    pub file_encryption: FileEncryptionConfig,
    pub database_encryption: DatabaseEncryptionConfig,
}

#[derive(Debug)]
pub struct DataProtectionManager {
    encryption_service: Arc<EncryptionService>,
    key_manager: Arc<KeyManager>,
    compliance_monitor: Arc<ComplianceMonitor>,
    data_classifier: Arc<DataClassifier>,
}

impl DataProtectionManager {
    pub async fn protect_sensitive_data(
        &self,
        data: &[u8],
        classification: DataClassification,
    ) -> Result<ProtectedData> {
        let protection_level = self.determine_protection_level(classification).await?;

        match protection_level {
            ProtectionLevel::None => {
                Ok(ProtectedData::Unprotected(data.to_vec()))
            }

            ProtectionLevel::Basic => {
                let encrypted = self.encryption_service.encrypt(data, &self.get_basic_key()).await?;
                Ok(ProtectedData::Encrypted {
                    data: encrypted,
                    key_id: "basic".to_string(),
                    algorithm: EncryptionAlgorithm::AES256GCM,
                })
            }

            ProtectionLevel::High => {
                let key_id = self.key_manager.generate_data_key().await?;
                let encrypted = self.encryption_service.encrypt(data, &key_id).await?;

                Ok(ProtectedData::HighSecurity {
                    data: encrypted,
                    key_id: key_id.id,
                    algorithm: EncryptionAlgorithm::ChaCha20Poly1305,
                    integrity_hash: self.calculate_integrity_hash(&encrypted).await?,
                })
            }

            ProtectionLevel::Maximum => {
                // Use envelope encryption with multiple keys
                let envelope_key = self.key_manager.generate_envelope_key().await?;
                let data_key = self.key_manager.generate_data_key().await?;

                let encrypted_data = self.encryption_service.encrypt(data, &data_key).await?;
                let encrypted_key = self.encryption_service.encrypt(&data_key.key, &envelope_key).await?;

                Ok(ProtectedData::EnvelopeEncrypted {
                    encrypted_data,
                    encrypted_key,
                    envelope_key_id: envelope_key.id,
                    data_key_id: data_key.id,
                    integrity_signature: self.sign_data(&encrypted_data).await?,
                })
            }
        }
    }
}
```

### Audit and Compliance

The system provides comprehensive audit logging and compliance monitoring:

```rust
#[derive(Debug)]
pub struct AuditLogger {
    log_writer: Arc<dyn AuditLogWriter>,
    compliance_monitor: Arc<ComplianceMonitor>,
    alert_manager: Arc<AlertManager>,
    retention_manager: Arc<RetentionManager>,
}

#[derive(Debug, Clone, Serialize)]
pub struct AuditEvent {
    pub id: AuditEventId,
    pub timestamp: DateTime<Utc>,
    pub event_type: AuditEventType,
    pub actor: Actor,
    pub resource: Resource,
    pub action: Action,
    pub outcome: Outcome,
    pub metadata: HashMap<String, serde_json::Value>,
    pub risk_score: Option<u8>,
}

#[derive(Debug, Clone, Serialize)]
pub enum AuditEventType {
    Authentication,
    Authorization,
    DataAccess,
    DataModification,
    SystemConfiguration,
    SecurityViolation,
    PerformanceAnomaly,
    ComplianceEvent,
}

impl AuditLogger {
    pub async fn log_event(&self, event: AuditEvent) -> Result<()> {
        // Calculate risk score if not provided
        let mut event_with_score = event;
        if event_with_score.risk_score.is_none() {
            event_with_score.risk_score = Some(self.calculate_risk_score(&event_with_score).await?);
        }

        // Write to audit log
        self.log_writer.write_event(&event_with_score).await?;

        // Check for compliance violations
        self.check_compliance(&event_with_score).await?;

        // Check for immediate alerts
        if event_with_score.risk_score.unwrap_or(0) > 7 {
            self.alert_manager.send_security_alert(&event_with_score).await?;
        }

        Ok(())
    }

    pub async fn generate_compliance_report(
        &self,
        standard: ComplianceStandard,
        time_period: TimePeriod,
    ) -> Result<ComplianceReport> {
        let events = self.get_events_for_period(time_period).await?;
        let analysis = self.compliance_monitor.analyze_events(&events, standard).await?;

        Ok(ComplianceReport {
            standard,
            time_period,
            total_events: events.len(),
            compliant_events: analysis.compliant_count,
            violations: analysis.violations,
            risk_assessment: analysis.risk_assessment,
            recommendations: analysis.recommendations,
            generated_at: Utc::now(),
        })
    }
}
```

## Monitoring and Observability

### Comprehensive Monitoring System

The system implements full-stack observability:

```rust
#[derive(Debug)]
pub struct MonitoringSystem {
    metrics_collector: Arc<MetricsCollector>,
    trace_collector: Arc<TraceCollector>,
    log_aggregator: Arc<LogAggregator>,
    alerting_engine: Arc<AlertingEngine>,
    dashboard_service: Arc<DashboardService>,
}

#[derive(Debug, Clone, Serialize)]
pub struct SystemMetrics {
    pub timestamp: DateTime<Utc>,
    pub system_health: SystemHealth,
    pub performance_metrics: PerformanceMetrics,
    pub resource_utilization: ResourceUtilization,
    pub error_rates: ErrorRates,
    pub business_metrics: BusinessMetrics,
}

#[derive(Debug, Clone, Serialize)]
pub struct SystemHealth {
    pub overall_status: HealthStatus,
    pub component_health: HashMap<String, ComponentHealth>,
    pub uptime_percent: f64,
    pub last_incident: Option<DateTime<Utc>>,
}

impl MonitoringSystem {
    pub async fn collect_system_metrics(&self) -> Result<SystemMetrics> {
        let timestamp = Utc::now();

        // Collect metrics from all components
        let system_health = self.collect_health_metrics().await?;
        let performance_metrics = self.collect_performance_metrics().await?;
        let resource_utilization = self.collect_resource_metrics().await?;
        let error_rates = self.collect_error_metrics().await?;
        let business_metrics = self.collect_business_metrics().await?;

        Ok(SystemMetrics {
            timestamp,
            system_health,
            performance_metrics,
            resource_utilization,
            error_rates,
            business_metrics,
        })
    }

    pub async fn setup_alerting_rules(&self) -> Result<()> {
        let rules = vec![
            AlertRule {
                name: "High Memory Usage".to_string(),
                condition: AlertCondition::Threshold {
                    metric: "memory_usage_percent".to_string(),
                    operator: ComparisonOperator::GreaterThan,
                    threshold: 90.0,
                    duration: Duration::from_minutes(5),
                },
                severity: AlertSeverity::Warning,
                actions: vec![
                    AlertAction::Email { recipients: vec!["ops@company.com".to_string()] },
                    AlertAction::Slack { channel: "#alerts".to_string() },
                ],
            },

            AlertRule {
                name: "Session Failure Rate".to_string(),
                condition: AlertCondition::Rate {
                    metric: "session_failures".to_string(),
                    rate_threshold: 0.05, // 5% failure rate
                    time_window: Duration::from_minutes(10),
                },
                severity: AlertSeverity::Critical,
                actions: vec![
                    AlertAction::PagerDuty { service_key: "session-failures".to_string() },
                    AlertAction::AutoRemediation { action: "restart_failed_sessions".to_string() },
                ],
            },

            AlertRule {
                name: "Claude API Rate Limit Exceeded".to_string(),
                condition: AlertCondition::Event {
                    event_type: "rate_limit_exceeded".to_string(),
                    frequency: EventFrequency::MoreThan { count: 3, within: Duration::from_minutes(15) },
                },
                severity: AlertSeverity::High,
                actions: vec![
                    AlertAction::Email { recipients: vec!["claude-ops@company.com".to_string()] },
                    AlertAction::AutoRemediation { action: "enable_adaptive_backoff".to_string() },
                ],
            },
        ];

        for rule in rules {
            self.alerting_engine.add_rule(rule).await?;
        }

        Ok(())
    }
}
```

### Performance Analytics

The system provides detailed performance analytics and optimization recommendations:

```rust
#[derive(Debug)]
pub struct PerformanceAnalyzer {
    metrics_store: Arc<MetricsStore>,
    trend_analyzer: Arc<TrendAnalyzer>,
    anomaly_detector: Arc<AnomalyDetector>,
    optimization_engine: Arc<OptimizationEngine>,
}

impl PerformanceAnalyzer {
    pub async fn generate_performance_insights(
        &self,
        time_window: Duration,
    ) -> Result<PerformanceInsights> {
        let metrics = self.metrics_store.get_metrics(time_window).await?;

        // Analyze trends
        let trends = self.trend_analyzer.analyze_trends(&metrics).await?;

        // Detect anomalies
        let anomalies = self.anomaly_detector.detect_anomalies(&metrics).await?;

        // Generate optimization recommendations
        let optimizations = self.optimization_engine
            .generate_recommendations(&metrics, &trends, &anomalies)
            .await?;

        Ok(PerformanceInsights {
            time_window,
            summary_metrics: self.calculate_summary_metrics(&metrics),
            trends,
            anomalies,
            bottlenecks: self.identify_bottlenecks(&metrics).await?,
            optimizations,
            predictive_analysis: self.generate_predictions(&trends).await?,
        })
    }

    async fn identify_bottlenecks(
        &self,
        metrics: &[SystemMetrics],
    ) -> Result<Vec<PerformanceBottleneck>> {
        let mut bottlenecks = Vec::new();

        // Analyze task execution times
        let task_times = metrics
            .iter()
            .flat_map(|m| m.business_metrics.task_execution_times.iter())
            .collect::<Vec<_>>();

        if let Some(p95_time) = self.calculate_percentile(&task_times, 95.0) {
            if p95_time > Duration::from_minutes(30) {
                bottlenecks.push(PerformanceBottleneck {
                    component: "task_execution".to_string(),
                    description: "High task execution times detected".to_string(),
                    impact: BottleneckImpact::High,
                    suggested_actions: vec![
                        "Review task complexity and decomposition strategies".to_string(),
                        "Optimize Claude Code context management".to_string(),
                        "Consider parallel task execution".to_string(),
                    ],
                });
            }
        }

        // Analyze resource utilization patterns
        let cpu_usage = metrics.iter()
            .map(|m| m.resource_utilization.cpu_percent)
            .collect::<Vec<_>>();

        if cpu_usage.iter().any(|&usage| usage > 95.0) {
            bottlenecks.push(PerformanceBottleneck {
                component: "cpu_utilization".to_string(),
                description: "CPU utilization consistently high".to_string(),
                impact: BottleneckImpact::Medium,
                suggested_actions: vec![
                    "Increase container CPU allocation".to_string(),
                    "Optimize CPU-intensive operations".to_string(),
                    "Consider horizontal scaling".to_string(),
                ],
            });
        }

        Ok(bottlenecks)
    }
}
```

This comprehensive configuration and security system provides robust operational management with sophisticated monitoring, compliance, and optimization capabilities for enterprise-grade deployment of the Claude Code Agent.