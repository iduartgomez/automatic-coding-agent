# 1.1 Architecture Overview

**Deliverable**: System architecture design and core component specifications
**Dependencies**: Foundation for all other deliverables (1.2-1.6)
**Implementation Priority**: Phase 1 - Core Foundation

## Executive Summary

The Claude Code Agent implements a sophisticated dual-mode architecture that separates orchestration concerns (host-side) from execution concerns (containerized). This design enables robust session management, comprehensive state persistence, and reliable long-running automation while maintaining security isolation and resource control.

**Key Architectural Principles:**
- **Separation of Concerns**: Clear boundaries between orchestration and execution
- **Fault Tolerance**: Comprehensive error handling and recovery mechanisms
- **Scalability**: Resource-aware design supporting 8+ hour continuous operation
- **Security**: Container isolation with minimal privilege principles
- **Observability**: Complete tracing and monitoring throughout the system

## System Architecture

The Claude Code Agent operates in a **dual-mode architecture** with clear separation between host-side orchestration and containerized execution. This design maximizes security, reliability, and maintainability while enabling sophisticated task automation workflows.

### Architecture Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                        Host System                          │
│  ┌─────────────────┐    ┌─────────────────────────────────┐ │
│  │   CLI Frontend  │    │     Session Manager             │ │
│  │   - Parse args  │────│   - Docker lifecycle           │ │
│  │   - Task input  │    │   - Volume management          │ │
│  │   - Config      │    │   - State persistence          │ │
│  └─────────────────┘    └─────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                    │
                                    │ Docker API
                                    ▼
┌─────────────────────────────────────────────────────────────┐
│                    Docker Container                         │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                 Agent Runtime                           │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ │ │
│  │  │Task Manager │  │Claude Code  │  │Session Context  │ │ │
│  │  │- Task tree  │  │Interface    │  │- Conversation   │ │ │
│  │  │- Scheduler  │  │- Headless   │  │- File changes   │ │ │
│  │  │- State mgmt │  │- Rate limit │  │- Build state    │ │ │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘ │ │
│  └─────────────────────────────────────────────────────────┘ │
│                                                             │
│  Volume Mounts:                                             │
│  /repos     (RO) - Source repositories (bind mount)       │
│  /workspace (RW) - Working directory (tmpfs/volume)        │
│  /session   (RW) - Persistent session data (volume)       │
│  /logs      (RW) - Session logs and outputs (volume)      │
│  /tmp       (RW) - Temporary files (tmpfs)                 │
└─────────────────────────────────────────────────────────────┘
```

### Communication Flows

```
Host System                    Container Runtime
     │                              │
     ├─── Docker API ─────────────► Container Lifecycle
     ├─── Volume Mounts ──────────► Persistent State
     ├─── Log Streaming ◄─────────── Execution Logs
     └─── Signal Handling ◄──────── Status Updates
```

## Core Components

The system consists of six primary components working in concert to provide reliable automated development workflows:

### 1. CLI Frontend & Session Manager (Host)

The host-side components handle system orchestration and provide the user interface:

**CLI Frontend Responsibilities:**
- Parse command-line arguments and validate configuration
- Accept task specifications through various input formats (JSON, interactive, file)
- Provide real-time status monitoring and progress reporting
- Handle user interruptions and graceful shutdown

**Session Manager Responsibilities:**
- Initialize and tear down Docker environments with proper volume mounts
- Manage container lifecycle (start, pause, resume, stop, cleanup)
- Handle session persistence and state checkpointing
- Monitor container health and resource usage
- Coordinate session resume operations after interruptions

**Component Architecture:**
```rust
pub struct SessionManager {
    docker_client: DockerClient,
    volume_manager: VolumeManager,
    state_store: StateStore,
    config: SessionConfig,
}

impl SessionManager {
    pub async fn initialize_session(&self, spec: TaskSpecification) -> Result<SessionId>;
    pub async fn resume_session(&self, id: SessionId) -> Result<AgentHandle>;
    pub async fn monitor_session(&self, id: SessionId) -> SessionMonitor;
    pub async fn cleanup_session(&self, id: SessionId, options: CleanupOptions) -> Result<()>;
}
```

**Key Operations:**
```bash
# Initialize new session with comprehensive configuration
init --tasks <file> --repos <path> --workspace <path> \
     [--config <file>] [--timeout <duration>] [--priority <level>]

# Resume existing session with optional checkpoint selection
resume --session-id <id> [--checkpoint <timestamp>] [--force-recovery]

# Monitor current session with real-time updates
status --session-id <id> [--detailed] [--follow] [--json]

# Clean up resources with preservation options
cleanup --session-id <id> [--preserve-workspace] [--preserve-logs] [--force]
```

### 2. Agent Runtime (Container)

The containerized agent runtime executes the core automation logic in an isolated environment:

**Agent Runtime Responsibilities:**
- Load and initialize session state from persistent storage
- Execute dynamic task tree with intelligent scheduling
- Interface with Claude Code through headless SDK
- Implement adaptive rate limiting and error recovery
- Maintain comprehensive execution logging and context

**Runtime Architecture:**
```rust
pub struct AgentRuntime {
    task_manager: TaskManager,
    claude_interface: ClaudeCodeInterface,
    context_manager: SessionContextManager,
    execution_engine: ExecutionEngine,
    persistence_layer: PersistenceLayer,
}
```

**Core Runtime Components:**

#### Task Manager
- Maintains hierarchical task tree with real-time updates
- Implements intelligent task selection and scheduling algorithms
- Handles dynamic subtask creation based on execution results
- Manages inter-task dependencies and context inheritance

#### Claude Code Interface
- Manages headless SDK connections and session state
- Implements token-aware rate limiting with adaptive backoff
- Handles structured request/response protocols
- Maintains conversation context across task boundaries

#### Session Context Manager
- Tracks file system changes and build artifacts
- Maintains conversation history and context windows
- Manages workspace state and dependency resolution
- Provides context optimization for related tasks

#### Execution Engine
- Coordinates task execution with proper resource management
- Implements timeout handling and cancellation semantics
- Manages parallel task execution where dependencies allow
- Provides execution metrics and performance monitoring

#### Persistence Layer
- Handles atomic state updates and transaction management
- Implements efficient checkpoint creation and restoration
- Manages data compression and storage optimization
- Provides data integrity validation and corruption recovery

## Execution Flow

The system operates through three distinct phases: initialization, execution, and completion/cleanup.

### 1. Initialization Phase

The system follows a structured initialization sequence:

```rust
async fn initialize_session(config: SessionConfig) -> Result<AgentSession> {
    // 1. Load or create session state
    let mut session = SessionState::load_or_create(&config.session_path)?;

    // 2. Parse and validate task specifications
    let task_tree = TaskTree::from_specification(&config.task_spec)?;
    session.set_task_tree(task_tree);

    // 3. Initialize Claude Code headless session
    let claude_interface = ClaudeCodeInterface::new(&config.claude_config).await?;

    // 4. Set up infrastructure
    let rate_limiter = RateLimiter::new(&config.rate_config);
    let logger = StructuredLogger::new(&config.log_config)?;

    Ok(AgentSession {
        session,
        claude_interface,
        rate_limiter,
        logger,
    })
}
```

### 2. Main Execution Loop

The agent runtime operates through a continuous execution cycle:

```rust
async fn run_execution_loop(mut session: AgentSession) -> Result<ExecutionSummary> {
    while session.has_pending_tasks() {
        // Task selection with intelligent prioritization
        let task = session.select_next_task().await?;

        match session.execute_task(&task).await {
            Ok(TaskResult::Completed(result)) => {
                session.mark_completed(&task, result).await?;
                session.process_task_result(&task, &result).await?;
                session.create_follow_up_tasks(&task, &result).await?;
            }

            Ok(TaskResult::Blocked(reason)) => {
                session.mark_blocked(&task, reason).await?;
                session.schedule_retry_or_escalate(&task).await?;
            }

            Err(TaskError::Transient(error)) => {
                session.handle_transient_error(&task, error).await?;
            }

            Err(TaskError::Permanent(error)) => {
                session.mark_failed(&task, error).await?;
                session.create_recovery_tasks(&task, &error).await?;
            }
        }

        // Periodic maintenance
        session.persist_state().await?;
        session.cleanup_resources().await?;

        if session.should_checkpoint() {
            session.create_checkpoint().await?;
        }
    }

    session.generate_completion_summary().await
}

// Enhanced execution with parallel task support
async fn run_parallel_execution(mut session: AgentSession) -> Result<ExecutionSummary> {
    let max_concurrent = session.config.max_concurrent_tasks;
    let mut active_tasks = FuturesUnordered::new();

    while session.has_pending_tasks() || !active_tasks.is_empty() {
        // Fill up to max concurrent tasks
        while active_tasks.len() < max_concurrent && session.has_eligible_tasks() {
            let task = session.select_next_task().await?;
            let task_future = session.execute_task_async(task);
            active_tasks.push(task_future);
        }

        // Wait for at least one task to complete
        if let Some(result) = active_tasks.next().await {
            session.process_completed_task(result).await?;
        }

        // Periodic maintenance
        session.maintain_session_health().await?;
    }

    session.generate_completion_summary().await
}
```

### 3. Task Selection Algorithm

The system implements sophisticated task prioritization:

**Selection Criteria (weighted scoring system):**

1. **Dependency Resolution** (Hard constraint): Only consider tasks whose dependencies are satisfied
2. **Priority Weighting** (40% of score): Higher priority tasks (1-10 scale) get preference
3. **Context Optimization** (25% of score): Favor tasks that share context with recent work
4. **Resource Availability** (15% of score): Consider current system resource utilization
5. **Error Recovery** (10% of score): Prioritize recovery tasks for recently failed operations
6. **Temporal Factors** (10% of score): Consider task age and urgency indicators

**Advanced Selection Features:**
- **Dynamic Priority Adjustment**: Priorities can be modified based on execution results
- **Context Clustering**: Group related tasks for batch execution efficiency
- **Load Balancing**: Distribute tasks across different system resources
- **Deadline Awareness**: Consider task deadlines and time constraints

**Implementation:**
```rust
impl TaskScheduler {
    async fn select_next_task(&self) -> Option<TaskId> {
        let eligible_tasks = self.get_eligible_tasks();

        let scored_tasks = eligible_tasks
            .iter()
            .map(|task| (task, self.calculate_task_score(task)))
            .collect::<Vec<_>>();

        scored_tasks
            .into_iter()
            .max_by(|(_, score_a), (_, score_b)| score_a.partial_cmp(score_b).unwrap())
            .map(|(task, _)| task.id)
    }

    fn calculate_task_score(&self, task: &Task) -> f64 {
        let priority_weight = task.metadata.priority as f64 * 10.0;
        let context_bonus = self.calculate_context_similarity(task) * 5.0;
        let urgency_factor = self.calculate_urgency_factor(task) * 2.0;

        let resource_penalty = self.calculate_resource_penalty(task) * -3.0;
        let deadline_urgency = self.calculate_deadline_urgency(task) * 7.0;
        let dependency_bonus = self.calculate_dependency_bonus(task) * 2.0;

        priority_weight + context_bonus + urgency_factor +
        resource_penalty + deadline_urgency + dependency_bonus
    }

    fn calculate_context_similarity(&self, task: &Task) -> f64 {
        let recent_files = self.get_recent_file_context();
        let task_files = &task.metadata.file_refs;

        let intersection = recent_files.intersection(task_files).count() as f64;
        let union = recent_files.union(task_files).count() as f64;

        if union > 0.0 { intersection / union } else { 0.0 }
    }
}
```

## Component Interfaces

### Host-Container Communication

The host and container communicate through:

1. **Volume Mounts**: Shared filesystem for persistent state
2. **Docker API**: Container lifecycle management
3. **Log Streaming**: Real-time execution monitoring
4. **Signal Handling**: Graceful shutdown and interruption

### Internal Component Communication

Within the container, components use:

1. **Event Bus**: Asynchronous event propagation between components
2. **Shared State**: Thread-safe state management with locks/channels
3. **Message Passing**: Structured communication for complex operations

### External System Interfaces

The system integrates with external systems through well-defined interfaces:

#### Claude Code SDK Integration
```rust
pub trait ClaudeCodeProvider {
    async fn create_session(&self, config: SessionConfig) -> Result<SessionHandle>;
    async fn send_message(&self, session: &SessionHandle, message: Message) -> Result<Response>;
    async fn stream_response(&self, session: &SessionHandle) -> Result<ResponseStream>;
    async fn get_usage_metrics(&self, session: &SessionHandle) -> Result<UsageMetrics>;
}
```

#### Version Control Integration
```rust
pub trait VcsProvider {
    async fn clone_repository(&self, repo: &Repository, target: &Path) -> Result<()>;
    async fn fetch_changes(&self, repo: &Path) -> Result<ChangeSet>;
    async fn create_branch(&self, repo: &Path, branch: &str) -> Result<()>;
    async fn commit_changes(&self, repo: &Path, message: &str) -> Result<CommitId>;
}
```

#### Build System Integration
```rust
pub trait BuildProvider {
    async fn detect_build_system(&self, path: &Path) -> Result<BuildSystem>;
    async fn run_build(&self, path: &Path, config: BuildConfig) -> Result<BuildResult>;
    async fn run_tests(&self, path: &Path, config: TestConfig) -> Result<TestResult>;
    async fn get_dependencies(&self, path: &Path) -> Result<DependencyGraph>;
}
```

## Resource Management

### Container Resource Allocation

```rust
pub struct ResourceLimits {
    pub cpu_limit: f64,           // CPU cores (e.g., 2.0)
    pub memory_limit: u64,        // Memory in bytes
    pub disk_quota: u64,          // Disk space in bytes
    pub network_bandwidth: u64,   // Network bandwidth in bytes/sec
    pub file_descriptors: u32,    // Max open file descriptors
}

pub struct ResourceMonitor {
    limits: ResourceLimits,
    current_usage: ResourceUsage,
    alerts: AlertManager,
}

impl ResourceMonitor {
    pub async fn check_resource_health(&self) -> ResourceHealth;
    pub async fn enforce_limits(&self) -> Result<()>;
    pub async fn predict_resource_needs(&self, task: &Task) -> ResourcePrediction;
}
```

### Memory Management Strategy

1. **Session State Optimization**: Efficient serialization with compression
2. **Context Window Management**: Dynamic context trimming and relevance scoring
3. **Cache Management**: LRU caching for frequently accessed data
4. **Memory Leak Prevention**: Periodic memory auditing and cleanup

## Performance Characteristics

### Scalability Targets

- **Task Throughput**: 50-100 tasks per hour (depending on complexity)
- **Session Duration**: Support 8+ hour continuous operation
- **Memory Usage**: <8GB per container with efficient state management
- **Storage Growth**: <100MB per hour of session data

### Optimization Strategies

1. **Context Reuse**: Maintain Claude Code sessions across related tasks
2. **Batch Operations**: Group file system and API operations
3. **Resource Monitoring**: Dynamic resource allocation and cleanup
4. **State Compression**: Efficient serialization of large session states

## Error Handling Strategy

### Error Classification

```rust
#[derive(Debug, Clone)]
pub enum SystemError {
    // Recoverable errors that should trigger retries
    Transient {
        error: String,
        retry_after: Duration,
        max_retries: u32,
    },

    // Task-specific errors that may need decomposition
    TaskFailed {
        task_id: TaskId,
        error: String,
        suggested_action: RecoveryAction,
    },

    // System-level errors requiring immediate attention
    Critical {
        component: Component,
        error: String,
        requires_restart: bool,
    },
}
```

### Recovery Mechanisms

```rust
pub struct RecoveryManager {
    retry_policies: HashMap<ErrorType, RetryPolicy>,
    escalation_rules: Vec<EscalationRule>,
    checkpoint_manager: CheckpointManager,
}

impl RecoveryManager {
    pub async fn handle_error(&self, error: SystemError, context: &TaskContext) -> RecoveryAction;
    pub async fn create_recovery_tasks(&self, failed_task: &Task, error: &SystemError) -> Vec<Task>;
    pub async fn escalate_to_human(&self, task: &Task, reason: &str) -> EscalationTicket;
}
```

**Recovery Strategies:**

1. **Automatic Retry**: Exponential backoff with jitter for transient failures
2. **Task Decomposition**: Intelligent breaking of complex failed tasks into simpler subtasks
3. **Context Reset**: Clean state recovery from known-good checkpoints
4. **Graceful Degradation**: Continue with reduced functionality when components fail
5. **Human Escalation**: Structured handoff for tasks requiring human intervention

## Integration Points

### Cross-Deliverable Dependencies

This architecture overview serves as the foundation for all other deliverables:

- **→ 1.2 Task Management**: Implements the Task Manager and Execution Engine components
- **→ 1.3 Session Persistence**: Implements the Persistence Layer and state management
- **→ 1.4 Claude Integration**: Implements the Claude Code Interface component
- **→ 1.5 Docker Deployment**: Implements the container orchestration and volume management
- **→ 1.6 Configuration & Security**: Implements security controls and monitoring systems

### Implementation Readiness

This architecture is designed for immediate implementation with:

- **Clear Component Boundaries**: Well-defined interfaces between all major components
- **Rust-Native Design**: Leverages Rust's safety and performance characteristics
- **Production Considerations**: Built-in monitoring, logging, and error handling
- **Scalability Path**: Architecture supports horizontal scaling and distributed execution

## Conclusion

This dual-mode architecture provides a robust, secure, and scalable foundation for automated development workflows. The clear separation between orchestration and execution, combined with comprehensive error handling and state management, enables reliable long-running automation while maintaining system security and observability.

The architecture's modular design ensures that each component can be developed, tested, and deployed independently while maintaining strong integration points for seamless system operation.